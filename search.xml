<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Tomorrow</title>
      <link href="/posts/0629/"/>
      <url>/posts/0629/</url>
      
        <content type="html"><![CDATA[<p>“无论你遇到谁，他都是你生命该出现的人，绝非偶然，他一定会教会你一些什么。”<br>“无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人。”</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> overwinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown规则</title>
      <link href="/posts/markdown/"/>
      <url>/posts/markdown/</url>
      
        <content type="html"><![CDATA[<p>参考markdownlint的rules文档，对每一个规则都进行了说明，指明了一些规则中可以设置的参数，便于用户设置相应的规则。</p><p>MD001 - Heading levels should only increment by one level at a time<br>标题级数每次只能扩大1, 也就是不能隔级创建标题（从1级到6级的顺序）</p><p>MD002 - First heading should be a top level heading<br>文档的第一个标题必须是最高级的标题（标题等级1级到6级逐渐降低）</p><p>参数：<br>“level”：指定最高级标题的级数，默认是1</p><p>MD003 - Heading style<br>整篇文档要采用一致的标题格式</p><p>参数：<br>“style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”, “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p><p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p><p>MD004 - Unordered list style<br>整篇文档定义无序列表的格式要一致</p><p>参数：<br>“style”：字符串，指定无序列表的定义格式，有(“consistent”, “asterisk”, “plus”, “dash”, “sublist”)五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是”consistent”</p><p>MD005 - Inconsistent indentation for list items at the same level<br>同一级的列表缩进必须一致<br>在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p><p>MD006 - Consider starting bulleted lists at the beginning of the line<br>1级列表不能缩进</p><p>MD007 - Unordered list indentation<br>无序列表嵌套缩进时默认采用两个空格</p><p>参数：<br>“ident”：指定无序列表嵌套时缩进的空格数，默认是2</p><p>MD009 - Trailing spaces<br>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p><p>参数：<br>“br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格<br>“list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p><p>MD010 - Hard tabs<br>不能使用tab键缩进，要使用空格</p><p>参数：<br>“code_blocks”：指定本条规则在代码块里是否(true or false)生效</p><p>MD011 - Reversed link syntax<br>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p><p>MD012 - Multiple consecutive blank lines<br>文档中不能有连续的空行，在代码块中此规则不会生效</p><p>参数：<br>“maximum”：指定文档中可以连续的最多空行数，默认值是1</p><p>MD013 - Line length<br>默认行的最大长度是80，此规则对代码块、表格、标题也生效</p><p>参数：<br>“line_length”：指定行的最大长度，默认是80<br>“heading_line_length”：指定标题行的最大长度，默认是80<br>“code_blocks”：指定规则是否(true or false)对代码块生效，默认true<br>“tables”：指定规则是否(true or false)对表格生效，默认true<br>“hesdings”：指定规则是否(true or false)对标题生效，默认true</p><p>MD014 - Dollar signs used before commands without showing output<br>在代码块中，终端命令前不需要有美元符号($)<br>如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p><p>$ ls foo bar $ cat foo hello world<br>MD018 - No space after hash on atx style heading<br>在”atx”格式的标题中，#号和文字间需用一个空格隔开</p><p>MD019 - Multiple spaces after hash on atx style heading<br>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p><p>MD020 - No space inside hashes on closed atx style heading<br>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p><p>MD021 - Multiple spaces inside hashes on closed atx style heading<br>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p><p>MD022 - Headings should be surrounded by blank lines<br>标题行的上下行必须都是空行</p><p>参数：<br>“lines_above”：指定标题行上方的空行数，默认为1，可以设为更大或0<br>“lines_below”：指定标题行下方的空行数，默认为1，可以设为更大或0</p><p>注意当此处的空行设为比1大的数时，规则MD012的设置也要改</p><p>MD023 - Headings must start at the beginning of the line<br>标题行不能缩进</p><p>MD024 - Multiple headings with the same content<br>文档不能有内容重复的标题</p><p>参数：<br>“siblings_only”：默认为false，设为true时，不同标题下的子标题内容可以重复</p><p>MD025 - Multiple top level headings in the same document<br>同一文档只能有一个最高级的标题，默认是只能有一个1级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是1<br>“front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p><p>MD026 - Trailing punctuation in heading<br>标题行末尾不能有以下标点符号：”.,;:!?”</p><p>参数：<br>“punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p><p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p><p>MD027 - Multiple spaces after blockquote symbol<br>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p><p>MD028 - Blank line inside blockquote<br>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p><p>MD029 - Ordered list item prefix<br>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字(“one_or_ordered”)</p><p>参数：<br>“style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是”one_or_ordered”</p><p>本条规则支持在前缀序号中补0，以实现对齐，如：</p><p>… 08. one 09. two 10. three …<br>MD030 - Spaces after list markers<br>列表（有序、无序）的前缀符号和文字之间用1个空格隔开<br>在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p><p>参数：<br>“ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1</p><p>MD031 - Fenced code blocks should be surrounded by blank lines<br>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块<br>MD032 - Lists should be surrounded by blank lines<br>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br>列表的缩进必须一致，否则会警告</p><p>MD033 - Inline HTML<br>文档中不允许使用HTML语句</p><p>参数：<br>“allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p><p>MD034 - Bare URL used<br>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p><p>MD035 - Horizontal rule style<br>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p><p>参数：<br>“style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***”,”—“,”___”)，默认是”consistent”</p><p>MD036 - Emphasis used instead of a heading<br>不能用强调代替标题</p><p>参数：<br>“punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p><p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p><p>MD037 - Spaces inside emphasis markers<br>用于创建强调的符号和强调的的文字之间不能有空格</p><p>MD038 - Spaces inside code span elements<br>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br>如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p><p>MD039 - Spaces inside link text<br>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：</p><p>MD040 - Fenced code blocks should have a language specified<br>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p><p>MD041 - First line in file should be a top level heading<br>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p><p>参数：<br>“level”：指定文档最高级的标题，默认是1<br>“front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p><p>MD042 - No empty links<br>链接的地址不能为空</p><p>MD043 - Required heading structure<br>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p><p>参数：<br>“headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p><p>[ “# head”, “## item”, “### detail”, “*” ]<br>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照MD043</p><p>MD044 - Proper names should have the correct capitalization<br>指定一些名称，会检查它是否有正确的大写</p><p>参数：<br>“names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br>“code_blocks”：指定本规则是否(true or false)对代码块生效，默认是true<br>一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数”names”中，防止写错</p><p>MD045 - Images should have alternate text (alt text)<br>图片链接必须包含描述文本（alt text）</p><p>MD046 - Code block style<br>整篇文档采用一致的代码格式</p><p>参数：<br>“style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p><p>MD047 - Files should end with a single newline character<br>文档需用一个空行结尾</p><p>参考：<br>rules文档</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 经典面试题汇总</title>
      <link href="/posts/spring/"/>
      <url>/posts/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><h3 id="1-1-不同版本的-Spring-Framework-有哪些主要功能"><a href="#1-1-不同版本的-Spring-Framework-有哪些主要功能" class="headerlink" title="1.1. 不同版本的 Spring Framework 有哪些主要功能"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能</h3><table><thead><tr><th>Version</th><th>Feature</th></tr></thead><tbody><tr><td>Spring 2.5</td><td>发布于 2007 年。这是第一个支持注解的版本。</td></tr><tr><td>Spring 3.0</td><td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td></tr><tr><td>Spring 4.0</td><td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td></tr></tbody></table><h3 id="1-2-什么是-Spring-Framework"><a href="#1-2-什么是-Spring-Framework" class="headerlink" title="1.2. 什么是 Spring Framework"></a>1.2. 什么是 Spring Framework</h3><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。<br>它是轻量级、松散耦合的。<br>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。<br>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</p><h3 id="1-3-列举-Spring-Framework-的优点"><a href="#1-3-列举-Spring-Framework-的优点" class="headerlink" title="1.3. 列举 Spring Framework 的优点"></a>1.3. 列举 Spring Framework 的优点</h3><p>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。<br>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。<br>由于依赖注入和控制反转，JDBC 得以简化。<br>它是开源免费的。</p><h3 id="1-4-Spring-Framework-有哪些不同的功能"><a href="#1-4-Spring-Framework-有哪些不同的功能" class="headerlink" title="1.4. Spring Framework 有哪些不同的功能"></a>1.4. Spring Framework 有哪些不同的功能</h3><p>轻量级 - Spring 在代码量和透明度方面都很轻便。<br>IOC - 控制反转<br>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。<br>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。<br>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。<br>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。<br>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p><h3 id="1-5-Spring-Framework-中有多少个模块，它们分别是什么"><a href="#1-5-Spring-Framework-中有多少个模块，它们分别是什么" class="headerlink" title="1.5. Spring Framework 中有多少个模块，它们分别是什么"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么</h3><p><img src="/" class="lazyload" data-src="/assets/Spring%20Framework%E6%A8%A1%E5%9D%97.jpg"  alt="Spring Framework模块"></p><p>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p><ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul><p>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：</p><ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul><p>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p><ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul><p><strong>AOP</strong> – 该层支持面向切面编程<br><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。<br><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。<br>几个杂项模块:</p><ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul><h3 id="1-6-什么是-Spring-配置文件"><a href="#1-6-什么是-Spring-配置文件" class="headerlink" title="1.6. 什么是 Spring 配置文件"></a>1.6. 什么是 Spring 配置文件</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p><h3 id="1-7-Spring-应用程序有哪些不同组件"><a href="#1-7-Spring-应用程序有哪些不同组件" class="headerlink" title="1.7. Spring 应用程序有哪些不同组件"></a>1.7. Spring 应用程序有哪些不同组件</h3><p>Spring 应用一般有以下组件：<br><strong>接口</strong> - 定义功能。<br><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。<br><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。<br><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。<br><strong>用户程序</strong> - 它使用接口。</p><h3 id="1-8-使用-Spring-有哪些方式"><a href="#1-8-使用-Spring-有哪些方式" class="headerlink" title="1.8. 使用 Spring 有哪些方式"></a>1.8. 使用 Spring 有哪些方式</h3><p>使用 Spring 有以下方式：</p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h2 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a>2、依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器"><a href="#2-1-什么是-Spring-IOC-容器" class="headerlink" title="2.1. 什么是 Spring IOC 容器"></a>2.1. 什么是 Spring IOC 容器</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p><p>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。<br><img src="/" class="lazyload" data-src="/assets/2.jpg"  alt="2"></p><h3 id="2-2-什么是依赖注入"><a href="#2-2-什么是依赖注入" class="headerlink" title="2.2. 什么是依赖注入"></a>2.2. 什么是依赖注入</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p><h3 id="2-3-可以通过多少种方式完成依赖注入"><a href="#2-3-可以通过多少种方式完成依赖注入" class="headerlink" title="2.3. 可以通过多少种方式完成依赖注入"></a>2.3. 可以通过多少种方式完成依赖注入</h3><p>通常，依赖注入可以通过三种方式完成，即：<br>构造函数注入<br>setter 注入<br>接口注入<br>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p><h3 id="2-4-区分构造函数注入和-setter-注入"><a href="#2-4-区分构造函数注入和-setter-注入" class="headerlink" title="2.4. 区分构造函数注入和 setter 注入"></a>2.4. 区分构造函数注入和 setter 注入</h3><p>构造函数注入 setter 注入<br>没有部分注入 有部分注入<br>不会覆盖 setter 属性 会覆盖 setter 属性<br>任意修改都会创建一个新实例 任意修改不会创建一个新实例<br>适用于设置很多属性 适用于设置少量属性</p><h3 id="2-5-spring-中有多少种-IOC-容器"><a href="#2-5-spring-中有多少种-IOC-容器" class="headerlink" title="2.5. spring 中有多少种 IOC 容器"></a>2.5. spring 中有多少种 IOC 容器</h3><p>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。<br>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</p><h3 id="2-6-区分-BeanFactory-和-ApplicationContext"><a href="#2-6-区分-BeanFactory-和-ApplicationContext" class="headerlink" title="2.6. 区分 BeanFactory 和 ApplicationContext"></a>2.6. 区分 BeanFactory 和 ApplicationContext</h3><table><thead><tr><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table><h3 id="2-7-列举-IoC-的一些好处"><a href="#2-7-列举-IoC-的一些好处" class="headerlink" title="2.7. 列举 IoC 的一些好处"></a>2.7. 列举 IoC 的一些好处</h3><p>IoC 的一些好处是：</p><ol><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ol><h3 id="2-8-Spring-IoC-的实现机制。"><a href="#2-8-Spring-IoC-的实现机制。" class="headerlink" title="2.8. Spring IoC 的实现机制。"></a>2.8. Spring IoC 的实现机制。</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">"io.github.dunwu.spring.Apple"</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Beans"><a href="#3、Beans" class="headerlink" title="3、Beans"></a>3、Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1. 什么是 spring bean？"></a>3.1. 什么是 spring bean？</h3><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2. spring 提供了哪些配置方式？"></a>3.2. spring 提供了哪些配置方式？</h3><ul><li>基于 xml 配置<br>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于注解配置<br>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于 Java API 配置<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</li></ul><ol><li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3. spring 支持集中 bean scope？"></a>3.3. spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p><ol><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ol><p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。更多spring内容</p><h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4. spring bean 容器的生命周期是什么样的？"></a>3.4. spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p><ol><li>Spring 容器根据配置中的 bean 定义中实例化 bean</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（ <bean>的 init-method 属性），那么将调用它。</li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li><li>如果为 bean 指定了 destroy 方法（ <bean>的 destroy-method 属性），那么将调用它。</li></ol><h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5. 什么是 spring 的内部 bean？"></a>3.5. 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg> 中提供了<bean>元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。<br>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Person person;    </span><br><span class="line">    <span class="comment">//Setters and Getters&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//Setters and Getters&#125;</span></span><br></pre></td></tr></table></figure><p>bean.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>" <span class="attr">class</span>=<span class="string">"com.edureka.Student"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span>        </span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.edureka.Person"</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">“Scott</span>"&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>"&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-什么是-spring-装配"><a href="#3-6-什么是-spring-装配" class="headerlink" title="3.6. 什么是 spring 装配"></a>3.6. 什么是 spring 装配</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p><h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7. 自动装配有哪些方式？"></a>3.7. 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p><ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul><h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8. 自动装配有什么局限？"></a>3.8. 自动装配有什么局限？</h3><ul><li>覆盖的可能性 - 您始终可以使用<constructor-arg> 和 <property>设置指定依赖项，这将覆盖自动装配。</li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h2 id="4、注-解"><a href="#4、注-解" class="headerlink" title="4、注 解"></a>4、注 解</h2><h3 id="4-1-你用过哪些重要的-Spring-注解？"><a href="#4-1-你用过哪些重要的-Spring-注解？" class="headerlink" title="4.1. 你用过哪些重要的 Spring 注解？"></a>4.1. 你用过哪些重要的 Spring 注解？</h3><ul><li>@Controller - 用于 Spring MVC 项目中的控制器类。</li><li>@Service - 用于服务类。</li><li>@RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。</li><li>@ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li><li>@PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</li><li>@Autowired - 用于在 spring bean 中自动装配依赖项。</li><li>@Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li><li>@Scope - 用于配置 spring bean 的范围。</li><li>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。</li><li>@Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。</li></ul><h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2. 如何在 spring 中启动注解装配？"></a>4.2. 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p><h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3. @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。<br>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。<br>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。<br>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4. @Required 注解有什么用？"></a>4.4. @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="meta">@Required</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.name=name;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> name;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5. @Autowired 注解有什么用？"></a>4.5. @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.name=name;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> name;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6. @Qualifier 注解有什么用？"></a>4.6. @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.name=name;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> name;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmpAccount.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="meta">@Qualifier</span>(emp1)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(“Employee name : ”+emp.getName);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7. @RequestMapping 注解有什么用？"></a>4.7. @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：</p><ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h2 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a>5、数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1. spring DAO 有什么用？"></a>5.1. spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h3 id="5-2-列举-Spring-DAO-抛出的异常。"><a href="#5-2-列举-Spring-DAO-抛出的异常。" class="headerlink" title="5.2. 列举 Spring DAO 抛出的异常。"></a>5.2. 列举 Spring DAO 抛出的异常。</h3><p><img src="/" class="lazyload" data-src="./assets/3.jpg"  alt="3"></p><h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3. spring JDBC API 中存在哪些类？"></a>5.3. spring JDBC API 中存在哪些类？</h3><p>JdbcTemplate<br>SimpleJdbcTemplate<br>NamedParameterJdbcTemplate<br>SimpleJdbcInsert<br>SimpleJdbcCall</p><h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4. 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：<br>使用 Hibernate 模板和回调进行控制反转<br>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</p><h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5. 列举 spring 支持的事务管理类型"></a>5.5. 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：<br>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。<br>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</p><h3 id="5-6-Spring-支持哪些-ORM-框架"><a href="#5-6-Spring-支持哪些-ORM-框架" class="headerlink" title="5.6. Spring 支持哪些 ORM 框架"></a>5.6. Spring 支持哪些 ORM 框架</h3><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1. 什么是 AOP？"></a>6.1. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.</p><p>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p><h3 id="6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？"><a href="#6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？" class="headerlink" title="6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？"></a>6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</h3><p><img src="/" class="lazyload" data-src="./assets/4.jpg"  alt="4"></p><ol><li>Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li><li>Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li><li>Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li><li>Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li><li>JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li></ol><h3 id="6-3-什么是通知（Advice）？"><a href="#6-3-什么是通知（Advice）？" class="headerlink" title="6.3. 什么是通知（Advice）？"></a>6.3. 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p><h3 id="6-4-有哪些类型的通知（Advice）？"><a href="#6-4-有哪些类型的通知（Advice）？" class="headerlink" title="6.4. 有哪些类型的通知（Advice）？"></a>6.4. 有哪些类型的通知（Advice）？</h3><ul><li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li><li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li><li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li></ul><h3 id="6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p><p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p><h3 id="6-6-AOP-有哪些实现方式？"><a href="#6-6-AOP-有哪些实现方式？" class="headerlink" title="6.6. AOP 有哪些实现方式？"></a>6.6. AOP 有哪些实现方式？</h3><ul><li>实现 AOP 的技术，主要分为两大类：</li><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li><li>JDK 动态代理</li><li>CGLIB</li></ul><h3 id="6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.7. Spring AOP and AspectJ AOP 有什么区别？"></a>6.7. Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</p><p>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p><h3 id="6-8-如何理解-Spring-中的代理？"><a href="#6-8-如何理解-Spring-中的代理？" class="headerlink" title="6.8. 如何理解 Spring 中的代理？"></a>6.8. 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advice + Target Object &#x3D; Proxy</span><br></pre></td></tr></table></figure><h3 id="6-9-什么是编织（Weaving）？"><a href="#6-9-什么是编织（Weaving）？" class="headerlink" title="6.9. 什么是编织（Weaving）？"></a>6.9. 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p><p><img src="/" class="lazyload" data-src="./assets/5.jpg"  alt="5"></p><h2 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a>7、MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1. Spring MVC 框架有什么用？"></a>7.1. Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p><h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2. 描述一下 DispatcherServlet 的工作流程"></a>7.2. 描述一下 DispatcherServlet 的工作流程</h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p><p><img src="/" class="lazyload" data-src="./assets/6.jpg"  alt="6"></p><ol><li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li><li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li><li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li></ol><ul><li>HttpMessageConveter：将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li><li>数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li></ul><ol start="5"><li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</li><li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li><li>ViewResolver 结合Model和View，来渲染视图。</li><li>视图负责将渲染结果返回给客户端。</li></ol><h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3. 介绍一下 WebApplicationContext"></a>7.3. 介绍一下 WebApplicationContext</h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础概念</title>
      <link href="/posts/42165/"/>
      <url>/posts/42165/</url>
      
        <content type="html"><![CDATA[<h1 id="类的特性"><a href="#类的特性" class="headerlink" title="类的特性"></a>类的特性</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>也就是Java中类的属性<br>例如创建一个鸟类 需要的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    String wing；</span><br><span class="line">    String claw；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>也就是Java中类的行为 例如猎豹的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leopard</span></span>&#123;</span><br><span class="line"><span class="comment">//凝视 就是方法 目标是taget</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gaze</span><span class="params">(String target)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在成员方法内定义的变量 在使用时必须进行赋值操作或被初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;  <span class="comment">//id就是局部变量</span></span><br><span class="line">    <span class="keyword">return</span> id + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套区域中不可以定义相同的名称和类型的局部变量</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>Java提供了this关键字，在类中，this代表类本身的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    String name = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book();</span><br><span class="line">            book.showName(<span class="string">"123"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为abc</p><h2 id="类修饰符"><a href="#类修饰符" class="headerlink" title="类修饰符"></a>类修饰符</h2><table><thead><tr><th></th><th>private</th><th>protecte</th><th>public</th></tr></thead><tbody><tr><td>本类</td><td>可见</td><td>可见</td><td>可见</td></tr><tr><td>同包其他类或子类</td><td>不可见</td><td>可见</td><td>可见</td></tr><tr><td>其他包的类或子类</td><td>不可见</td><td>不可见</td><td>可见</td></tr></tbody></table><p>default package 默认包</p><h1 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h1><p>构造方法是一个与类同名的方法，对象的创建就是通过构造方法完成的。每当类实例化一个对象时，类都会自动调用构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//Bird的类的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h2><p>程序运行的入口  也就是main方法  主方法是类的入口点，它定义了程序从何处开始，主方法提供对程序流向的控制，Java编译器通过主方法来执行程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主方法是静态的，如果直接在主方法中调用其他方法，则该方法必须是静态的。<br>主方法没有返回值。<br>主方法的形参为数组。<br>静态方法总是先执行。<br>tmp：a  临时的a</p><h2 id="面向对象-Object"><a href="#面向对象-Object" class="headerlink" title="面向对象 Object"></a>面向对象 Object</h2><p>世间万物皆对象 看的到的都是对象 是事物存在的实体<br>1.静态部分，被称为“属性”，如人的性别，高矮，胖瘦。。<br>2.动态部分，对象的行为，如人可以微笑，走路。。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是同一类事物的统称，如果一个事物抽象成对象，类就是这类对象的统称，如鸟类，人类。<br>类就是对象的设计图。</p><h1 id="面向对象编程设计的特征"><a href="#面向对象编程设计的特征" class="headerlink" title="面向对象编程设计的特征"></a>面向对象编程设计的特征</h1><p>三大特征：1.封装  2.继承 3.多态<br>(其实还有第四个特征：抽象。也就是对象和类的概念)</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是面向对象编程的核心思想，将对象的属性和行为封装起来，而将对象的属性和行为封装起来的载体就是类，类通常对客户隐藏其实现细节，这就是封装的思想。<br>(如用户使用计算机，只需要使用手指敲击键盘就可以实现一些功能，无需知道计算机内部是如何工作的) 写一个类，不需要知道这个类怎么实现的，只要它提供了方法供使用者调用。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当处理一个问题时，可以将一些有用的类保留下来，这些类通常有相同的属性，甚至相同的方法，当遇到同样问题时可以拿来复用。例如鸽子具有与鸟类相同的属性和行为。在创建信鸽类时将鸟类拿来复用，并保留鸟类具有的属性和行为。</p><p>继承性主要利用特定对象之间的共有属性。例如，矩形是四边形，矩形与四边形具有共同的特性，也就是4个边，可以将矩形类看作四边形的延申，矩形复用了四边形的属性和行为，同时添加了矩形独有的属性和行为。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>继承中，存在父类和子类，其实将父类对象应用于子类的特征就是多态。<br>多态性允许以统一的风格编写程序，以处理种类繁多的已存在的类以及相关类。该统一风格可以由父类来实现，根据父类统一风格的处理，就可以实例化子类的对象。由于整个事件的处理都只依赖于父类的方法，所以日后只要维护和调整父类的方法即可，这样就降低了维护的难度，节省了时间。</p><p>一个类衍生出不同的子类，子类继承了父类的特征，子类又有自己的特点，这个就是多态化的结构。</p><p>编译看左，运行看右(覆盖重写)</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/posts/2020/"/>
      <url>/posts/2020/</url>
      
        <content type="html"><![CDATA[<p>抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束<br>抽象类：抽象方法所在的类，必须是抽象类才才行。在class之前写上abstract即可</p><p>如何使用:<br>1.不能直接创建new抽象类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.必须用一个子类来继承抽象父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line"><span class="number">3</span>.子类必须覆盖重写父类当中所有的抽象方法</span><br><span class="line">覆盖重写(实现)：子类去掉抽象方法的<span class="keyword">abstract</span>关键字，然后补上方法大括号&#123;&#125;</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="comment">//测试的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sout(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建子类对象进行使用</p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{    psvm        Cat cat = <span class="keyword">new</span> Cat()；        cat.eat();}```  <span class="comment">//输出的就是  猫吃鱼</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/520520/"/>
      <url>/posts/520520/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
